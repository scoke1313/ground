
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=393, height=712, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>둥둥그라운드 v1.6.2.9 - 표정 복구 정밀 수정</title>
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        body { margin: 0; padding: 0; background-color: #333; font-family: 'Pretendard', sans-serif; overflow: hidden; touch-action: none; user-select: none; display: flex; justify-content: center; align-items: center; height: 100vh; }
        #game-container { position: relative; width: 393px; height: 712px; overflow: hidden; background: #C0EEFE; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
        canvas { display: block; width: 100%; height: 100%; outline: none; -webkit-tap-highlight-color: transparent; }
        #hud { position: absolute; top: 0; left: 0; width: 100%; z-index: 50; display: none; pointer-events: none; }
        .nav-bar img { width: 100%; display: block; }
        .hud-info { width: 100%; padding: 15px 20px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: flex-start; }
        .dist-val-wrap { font-size: 32px; font-weight: 800; color: #000; letter-spacing: -1px; line-height: 1; margin-top: 2px; }
        .combined-badge { background: #fff; padding: 6px 14px; border-radius: 30px; display: flex; align-items: center; gap: 12px; box-shadow: none; }
        .life-icon { width: 30px; height: 30px; object-fit: contain; }
        .score-icon { width: 30px; height: 30px; object-fit: contain; margin-right: 6px; }
        #life-container { display: flex; gap: 4px; padding-left: 5px; } 
        #result-screen { position: absolute; inset: 0; background: rgba(0,0,0,0.8); z-index: 200; display: none; flex-direction: column; justify-content: center; align-items: center; color: white; text-align: center; }
        #score-val { font-size: 20px; font-weight: 600; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="main-screen" style="position:absolute; inset:0; background:url('bg_main.png') no-repeat center center / cover; z-index:100; display:flex; justify-content:center;">
        <img src="btn_start.png" id="start-btn" style="position:absolute; bottom:8%; width:85%; cursor:pointer;" onclick="forceStart()">
    </div>
    
    <div id="hud">
        <div class="nav-bar"><img src="ingae_Navigation.png"></div>
        <div class="hud-info">
            <div class="dist-group">
                <span style="font-size:14px; font-weight:500; color:#555;">현재 고도</span>
                <div class="dist-val-wrap"><span id="dist-val">1500</span>m</div>
            </div>
            <div class="combined-badge">
                <div class="score-item" style="display:flex; align-items:center;">
                    <img src="create_s.png" class="score-icon">
                    <span id="score-val">0</span>
                </div>
                <div id="life-container">
                    <img id="life-0" src="mini_life.png" class="life-icon">
                    <img id="life-1" src="mini_life.png" class="life-icon">
                    <img id="life-2" src="mini_life.png" class="life-icon">
                </div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="result-screen">
        <h1 id="result-title" style="font-size: 48px; font-weight: 900;">작전 완료!</h1>
        <p>획득한 보급: <span id="final-score">0</span>개</p>
        <img src="btn_start.png" style="width: 70%; cursor:pointer;" onclick="location.reload()">
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const WIDTH = 393 * 2, HEIGHT = 712 * 2; 
    canvas.width = WIDTH; canvas.height = HEIGHT;
    const ctx = canvas.getContext('2d');

    const imgs = {};
    const imgList = [
        'player', 'dong_chun.png', 
        'face_happy', 'dong_chun_happy.png', 
        'face_miss', 'dong_chun_miss.png', 
        'crate', 'create_m.png', 'gold', 'gold.png', 'heli', 'heli.png', 'cloud1', 'cloud_1.png', 'cloud2', 'cloud_2.png', 'cloud3', 'cloud_3.png', 'land', '03_ingame_land.png', 'effect', 'effect_pickup.png', 'damage', 'damege.png', 'mountain', 'surface_mountain.png', 'grass', 'surface_grass.png', 'target', 'surface_target.png'
    ];
    imgList.forEach((val, i) => { if(i % 2 === 0) { imgs[val] = new Image(); imgs[val].src = imgList[i+1]; } });

    let state = 'MAIN', frame = 0, dist = 1500, score = 0, lives = 3;
    const pX = WIDTH / 2, pY = HEIGHT * 0.28;
    let pDir = 1, objects = [], clouds = [], fx = [];
    let stopSpawning = false, mountainX = 0, grassX = 0, hitShakeFrame = 0;
    
    // 표정 관리 변수
    let faceTimer = 0;
    let currentFace = 'normal';

    let flashFrame = 0, flashColor = "rgba(255, 0, 0, 0.3)";
    let currentRotation = 0, rotVel = 0;
    const targetRotationLeft = 0, targetRotationRight = -27 * Math.PI / 180;
    const springK = 0.18, friction = 0.75; 
    const GLOBAL_SPEED = 14; 
    let landY = HEIGHT + 1000, spawnDeck = [];

    function forceStart() {
        document.getElementById('main-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        state = 'PLAY';
        for(let j=0; j<5; j++) spawnCloud(Math.random() * HEIGHT);
        loop();
    }

    function refillSpawnDeck() {
        let newItems = ['GOLD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD', 'BAD'];
        for(let i=0; i<90; i++) { newItems.push('CRATE'); }
        for (let i = newItems.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newItems[i], newItems[j]] = [newItems[j], newItems[i]]; }
        spawnDeck = [...spawnDeck, ...newItems];
    }

    function spawnCloud(y) {
        const depth = Math.floor(Math.random() * 2);
        const baseScale = depth === 0 ? 0.39 : 0.26;
        clouds.push({ x: Math.random() * WIDTH, y: y || HEIGHT + 150, img: imgs['cloud'+(Math.floor(Math.random()*3)+1)], scale: baseScale * 1.3, alpha: depth === 0 ? 0.8 : 0.5, speed: depth === 0 ? 3.5 : 1.8, depth });
    }

    function spawnObj() {
        if(stopSpawning) return;
        if(spawnDeck.length < 5) refillSpawnDeck();
        const type = spawnDeck.shift(); 
        let x = Math.random() * (WIDTH - 120) + 60; 
        const spawnY = HEIGHT + 200;

        if(type === 'BAD') {
            const tooClose = objects.some(o => o.type === 'BAD' && Math.abs(o.x - x) < 180); 
            if(tooClose) x = (x + 250) % (WIDTH - 120) + 60;
            objects.push({ x, y: spawnY, type: 'BAD', img: imgs.heli });
        } else if(type === 'GOLD') {
            objects.push({ x, y: spawnY, type: 'GOLD', img: imgs.gold });
        } else {
            const patternRand = Math.random();
            if(patternRand > 0.85) { 
                objects.push({ x: Math.max(80, x - 70), y: spawnY, type: 'CRATE', img: imgs.crate });
                objects.push({ x: Math.min(WIDTH - 80, x + 70), y: spawnY, type: 'CRATE', img: imgs.crate });
            } else if(patternRand > 0.7) {
                objects.push({ x, y: spawnY, type: 'CRATE', img: imgs.crate });
                objects.push({ x: (x + 150) % (WIDTH - 120) + 60, y: spawnY + 120, type: 'CRATE', img: imgs.crate });
            } else {
                objects.push({ x, y: spawnY, type: 'CRATE', img: imgs.crate });
            }
        }
    }

    function triggerGoldFever() {
        currentFace = 'happy';
        faceTimer = 78; // 1.3초 고정
        objects.forEach(o => { if(o.type === 'CRATE') score++; fx.push({ x: o.x, y: o.y, img: imgs.effect, life: 108, follow: false, vx: 0, vy: -GLOBAL_SPEED, type: 'PICKUP' }); });
        objects = [];
    }

    function updateLifeUI() { for(let i=0; i<3; i++) { document.getElementById('life-' + i).src = (i < lives) ? 'mini_life.png' : 'mini_death.png'; } }

    function gameOver(title) {
        state = 'END';
        document.getElementById('result-title').innerText = title;
        document.getElementById('final-score').innerText = score;
        document.getElementById('result-screen').style.display = 'flex';
    }

    canvas.addEventListener('mousedown', () => { if(state === 'PLAY') pDir *= -1; });
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); if(state === 'PLAY') pDir *= -1; }, {passive: false});

    function loop() {
        if(state === 'END') return;
        frame++; 
        const scrollSpeed = (state === 'LANDED') ? 0 : 10; 
        let targetRot = (pDir === 1) ? targetRotationLeft : targetRotationRight;
        let force = (targetRot - currentRotation) * springK;
        rotVel = (rotVel + force) * friction;
        currentRotation += rotVel;

        if(state === 'PLAY') {
            dist -= 1.41; 
            mountainX -= pDir * 1.8; 
            grassX -= pDir * scrollSpeed;
        }

        document.getElementById('dist-val').innerText = Math.max(0, Math.floor(dist));
        document.getElementById('score-val').innerText = score;

        const targetArrivalY = pY + 140 - 248;
        if(dist < 150 && state === 'PLAY') {
            if(landY > targetArrivalY) landY -= GLOBAL_SPEED; 
            else {
                landY = targetArrivalY;
                if(dist <= 5) { 
                    dist = 0; state = 'LANDED'; 
                    setTimeout(() => { if(state !== 'END') gameOver("작전 완료!"); }, 500); 
                }
            }
            stopSpawning = true;
        }

        if(state === 'PLAY') {
            const spawnInterval = 7 + Math.floor(Math.random() * 4);
            if(frame % spawnInterval === 0) spawnObj();
            if(frame % 80 === 0) spawnCloud();
        }

        clouds.forEach((c, i) => { 
            c.y -= (state === 'LANDED') ? 0 : c.speed; 
            c.x -= (state === 'LANDED') ? 0 : pDir * c.speed * 0.3; 
            if(c.y < -350) clouds.splice(i,1); 
        });

        objects.forEach((o, i) => {
            o.y -= GLOBAL_SPEED; o.x -= pDir * 10;
            if(o.y < -150) { objects.splice(i, 1); return; } 

            const dx = pX - o.x, dy = pY - o.y;
            if(state === 'PLAY' && Math.sqrt(dx*dx + dy*dy) < 115) {
                if(o.type === 'BAD') {
                    lives--; updateLifeUI(); hitShakeFrame = 10; flashFrame = 10;
                    currentFace = 'miss'; 
                    faceTimer = 78; // 1.3초 고정
                    fx.push({ x: pX + 90, y: pY - 140, img: imgs.damage, life: 40, follow: true, type: 'DAMAGE', scale: 0.8 });
                    if(lives <= 0) setTimeout(() => { gameOver("작전 실패..."); }, 500);
                } else if(o.type === 'GOLD') {
                    triggerGoldFever();
                } else {
                    score++; 
                    currentFace = 'happy'; 
                    faceTimer = 78; // 요청하신 대로 보급상자 획득 시에도 1.3초 유지
                    fx.push({ x: o.x, y: o.y, img: imgs.effect, life: 108, follow: false, vy: -GLOBAL_SPEED, type: 'PICKUP' }); 
                }
                objects.splice(i, 1);
            }
        });

        fx.forEach((f, i) => { if(f.life > 0) f.life--; else fx.splice(i, 1); if(!f.follow) { f.x -= pDir * 10; f.y += f.vy; if(f.y < -150) fx.splice(i, 1); } });
        if(hitShakeFrame > 0) hitShakeFrame--;
        if(flashFrame > 0) flashFrame--; 
        
        draw();
        requestAnimationFrame(loop);
    }

    function draw() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        ctx.fillStyle = '#C0EEFE'; ctx.fillRect(0, 0, WIDTH, HEIGHT);
        
        clouds.sort((a, b) => b.depth - a.depth).forEach(c => {
            ctx.save(); ctx.globalAlpha = c.alpha;
            ctx.drawImage(c.img, c.x - (300*c.scale)/2, c.y, 300*c.scale, 180*c.scale);
            ctx.restore();
        });

        ctx.save();
        ctx.beginPath(); ctx.rect(0, 130, WIDTH, HEIGHT); ctx.clip();

        if(dist < 150) {
            if(imgs.mountain.complete) {
                const mW = 600 * 1.65, mH = 120 * 1.65;
                for(let x = -3; x <= 3; x++) ctx.drawImage(imgs.mountain, ((mountainX * 1.0) % mW) + (x * mW), landY - mH, mW, mH);
            }
            if(imgs.grass.complete) {
                ctx.fillStyle = '#7AC6A6'; ctx.fillRect(0, landY, WIDTH, HEIGHT + 1200);
                for(let x = -2; x <= 2; x++) ctx.drawImage(imgs.grass, ((grassX * 1.0) % WIDTH) + (x * WIDTH), landY, WIDTH, 370);
            }
            if(imgs.target.complete) ctx.drawImage(imgs.target, pX - 120, landY + 100, 240, 240);
        }

        objects.forEach(o => {
            if(o.type === 'GOLD') { ctx.save(); ctx.shadowBlur = 30; ctx.shadowColor = "yellow"; ctx.drawImage(o.img, o.x - 50, o.y, 100, 100); ctx.restore(); }
            else if(o.type === 'BAD') { ctx.drawImage(o.img, o.x - (216 * 1.065)/2, o.y, 216 * 1.065, 146 * 1.065); }
            else ctx.drawImage(o.img, o.x - 50, o.y, 100, 100);
        });

        // 춘식이 본체 렌더링
        ctx.save();
        let sX = (hitShakeFrame > 0) ? (Math.random() - 0.5) * 25 : 0;
        ctx.translate(pX + sX, pY + Math.sin(frame*0.08)*7.5);
        ctx.rotate(currentRotation); 
        
        if(hitShakeFrame % 4 > 1) ctx.globalAlpha = 0.5;

        // 표정 복구 로직: Timer가 0보다 클 때만 특수 표정, 아니면 무조건 일반 표정
        let pImg = imgs.player;
        if(faceTimer > 0) {
            pImg = (currentFace === 'happy') ? imgs.face_happy : imgs.face_miss;
            faceTimer--; // loop가 아닌 draw에서 실시간 차감하여 렌더링과 동기화
        }

        if(pImg && pImg.complete) { ctx.drawImage(pImg, -143, -143, 286, 286); }
        ctx.restore();

        fx.forEach(f => {
            ctx.save();
            let opacity = 1.0;
            const totalLife = 108; if(f.type === 'PICKUP') { if(f.life > 102) opacity = (108 - f.life) / 6; else if(f.life <= 12) opacity = f.life / 12; }
            ctx.globalAlpha = opacity;
            const bW = 140, bH = 84, sc = f.scale || 1.0;
            ctx.drawImage(f.img, (f.follow ? (f.type === 'DAMAGE' ? pX + 90 : pX) : f.x) - (bW * sc)/2, (f.follow ? pY : f.y) - 100, bW * sc, bH * sc);
            ctx.restore();
        });
        ctx.restore(); 

        if(flashFrame > 0) { ctx.fillStyle = flashColor; ctx.fillRect(0, 0, WIDTH, HEIGHT); }
    }
    draw();
</script>
</body>
</html>
